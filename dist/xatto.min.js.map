{"version":3,"sources":["dist/xatto.js"],"names":["global","factory","exports","module","define","amd","xatto","this","CONTEXT","EXTRA","FILL","PATH","SLICE","TEXT","MIDDLEWARES","CHILDREN","KEY","NAME","PROPS","ELEMENT","LIFECYCLE","PREV_PROPS","PREV","CREATE","DESTROY","REMOVE","UPDATE","assign","target","source","key","hasOwnProperty","deepSet","value","separator","idx","indexOf","current","slice","nexts","next","split","parseInt","createGlueNode","vNode","recursion","newGlueNode","i","map","child","TEXT_NODE","createVNode","mayBeTextNode","name","props","children","node","noop","deepGet","mutate","getContext","setContext","scheduleRender","context","path","Promise","then","newContext","targetContext","remodelProps","extra","shouldBeCaptureLifecycles","glueNodeMerger","removedNodes","captureLifecycle","glueNode","lifecycle_1","rawLifecycle","shouldBeCaptureLifecycle","shouldBeCaptureLifecycleByCaptured","lifecycle","get","resolveLifecycle","indexedPrevChildren","prevChild","_prevChild","length","splice","unshift","index","push","XLINK_NS","updateAttribute","element","oldValue","isSVG","eventProxy","eventName","Function","addEventListener","removeEventListener","nullOrFalse","removeAttribute","ns","originName","replace","setAttribute","setAttributeNS","removeAttributeNS","patcher","destroys","lifecycleEvents","eventTargetProps","_a","lifecycleEvent","detail","document","createTextNode","createElementNS","createElement","name_1","set","createNode","prevProps","updated","nodeValue","updateNode","parent","parentElement","parentNode","removeChild","has","done","resolve","elm","type","events","CustomEvent","event","dispatchEvent","fireLifeCycleEventProvider","reduce","acc","childNode","patchedChild","concat","v","reduceRight","ref","insertBefore","isVNode","x","rest","_i","arguments","pop","Array","isArray","resolveChildren","childs","apply","resolverProvider","rawProps","parentProps","parentPath","sliced","resolved","resolver","rendererProvider","WeakMap","currentTarget","_","destroy","wrapOnion","stack","atto","view","containerOrGlueNode","options","scheduled","Element","nodeName","rootContext","middlewares","render","rendered","renderedError","rendererProviders","provider","def","renderers","args","finallyer","vNodes","container","rendering","e","currentOnly","eventHandler"],"mappings":"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","sourcesContent":["/*\nxatto v1.0.0-rc.7\nhttps://github.com/atomita/xatto\nReleased under the MIT License.\n*/\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.xatto = {})));\n}(this, (function (exports) { 'use strict';\n\n  var CONTEXT = 'xa.context';\r\n  var EXTRA = 'xa.extra';\r\n  var FILL = 'xa.fill';\r\n  var PATH = 'xa.path';\r\n  var SLICE = 'xa.slice';\r\n  var TEXT = 'xa.text';\n\n  var MIDDLEWARES = 'middlewares';\n\n  var CHILDREN = 'children';\r\n  var KEY = 'key';\r\n  var NAME = 'name';\r\n  var PROPS = 'props';\n\n  var ELEMENT = 'element';\r\n  var LIFECYCLE = 'lifecycle';\r\n  var PREV = 'prev';\r\n  var PREV_PROPS = PREV + \".\" + PROPS;\n\n  var CREATE = 'create';\r\n  var DESTROY = 'destroy';\r\n  var REMOVE = 'remove';\r\n  var UPDATE = 'update';\n\n  function assign(target, source) {\r\n      for (var key in source) {\r\n          if (source.hasOwnProperty(key)) {\r\n              target[key] = source[key];\r\n          }\r\n      }\r\n      return target;\r\n  }\n\n  /**\r\n   * Set an object item to a given value using separator notation.\r\n   *\r\n   * @param {any} target\r\n   * @param {string} key\r\n   * @param {any} value\r\n   * @param {string} separator\r\n   * @return {boolean}\r\n   */\r\n  function deepSet(target, key, value, separator) {\r\n      if (separator === void 0) { separator = '.'; }\r\n      while (true) {\r\n          if ('object' !== typeof target) {\r\n              return false;\r\n          }\r\n          var idx = key.indexOf(separator);\r\n          if (idx < 0) {\r\n              target[key] = value;\r\n              return true;\r\n          }\r\n          var current = key.slice(0, idx);\r\n          var nexts = key.slice(idx + 1);\r\n          if (null == target[current]) {\r\n              var next = nexts.split(separator, 1)[0];\r\n              target[current] = next === \"\" + parseInt(next, 10) ? [] : {};\r\n          }\r\n          target = target[current];\r\n          key = nexts;\r\n      }\r\n  }\n\n  function createGlueNode(vNode, next, recursion) {\r\n      var newGlueNode = assign({}, vNode);\r\n      newGlueNode.i = 0;\r\n      newGlueNode[LIFECYCLE] = CREATE;\r\n      newGlueNode[CHILDREN] = vNode[CHILDREN].map(function (child) { return recursion(CREATE, child); });\r\n      deepSet(newGlueNode, PREV_PROPS, {});\r\n      return newGlueNode;\r\n  }\n\n  var TEXT_NODE = 'xa-txt';\n\n  function createVNode(mayBeTextNode, name, props, children) {\r\n      if (props === void 0) { props = {}; }\r\n      if (children === void 0) { children = []; }\r\n      var node = {};\r\n      node[NAME] = name;\r\n      node[PROPS] = props;\r\n      node[CHILDREN] = children;\r\n      node[KEY] = props.key;\r\n      if (mayBeTextNode && 'function' !== typeof name) {\r\n          node[NAME] = TEXT_NODE;\r\n          deepSet(node[PROPS], TEXT, name);\r\n      }\r\n      return node;\r\n  }\n\n  function noop() { }\n\n  function createGlueNodeByElement(element) {\r\n      var node = createGlueNode(createVNode(false, element.nodeName), noop, noop);\r\n      node[ELEMENT] = element;\r\n      return node;\r\n  }\n\n  /**\r\n   * Get an item from an object using separator notation.\r\n   *\r\n   * @typeparam {T}\r\n   * @param {any} target\r\n   * @param {string} key\r\n   * @param {string} separator\r\n   * @return {T}\r\n   */\r\n  function deepGet(target, key, separator) {\r\n      if (separator === void 0) { separator = '.'; }\r\n      while (true) {\r\n          if (target == null) {\r\n              return target;\r\n          }\r\n          var idx = key.indexOf(separator);\r\n          if (idx < 0) {\r\n              return target[key];\r\n          }\r\n          target = target[key.slice(0, idx)];\r\n          key = key.slice(idx + 1);\r\n      }\r\n  }\n\n  function mutate(getContext, setContext, scheduleRender, context, path) {\r\n      if (context) {\r\n          if (context instanceof Promise) {\r\n              return context.then(function (newContext) { return mutate(getContext, setContext, scheduleRender, newContext, path); });\r\n          }\r\n          if ('function' === typeof context) {\r\n              return context(mutate, getContext);\r\n          }\r\n          if ('object' === typeof context) {\r\n              var targetContext = getContext(path);\r\n              if (context === targetContext) {\r\n                  return;\r\n              }\r\n              var newContext = assign(assign({}, targetContext), context);\r\n              setContext(newContext, path);\r\n              scheduleRender();\r\n          }\r\n      }\r\n  }\n\n  function mutateProvider(getContext, setContext, scheduleRender) {\r\n      return function (context, path) {\r\n          if (path === void 0) { path = ''; }\r\n          return mutate(getContext, setContext, scheduleRender, context, path);\r\n      };\r\n  }\n\n  function remodelProps(props, context, extra, path) {\r\n      deepSet(props, CONTEXT, context || deepGet(props, CONTEXT) || {});\r\n      deepSet(props, EXTRA, extra || deepGet(props, EXTRA) || {});\r\n      deepSet(props, PATH, path || '');\r\n      return props;\r\n  }\n\n  function eventProxyProvider(mutate, getContext, eventTargetProps) {\r\n      return function (event) {\r\n          var node = event.currentTarget;\r\n          var props = eventTargetProps.get(node) || {};\r\n          var path = deepGet(props, PATH) || '';\r\n          var detail = event.detail || {};\r\n          var newContext = props[\"on\" + event.type](getContext(path), detail, props, event);\r\n          mutate(newContext, path);\r\n      };\r\n  }\n\n  var shouldBeCaptureLifecycles = {};\r\n  shouldBeCaptureLifecycles[REMOVE] = 1;\r\n  shouldBeCaptureLifecycles[DESTROY] = 2;\r\n  function resolveLifecycle(rawLifecycle, captureLifecycle, glueNode, removedNodes) {\r\n      var shouldBeCaptureLifecycle = shouldBeCaptureLifecycles[rawLifecycle];\r\n      var shouldBeCaptureLifecycleByCaptured = shouldBeCaptureLifecycles[captureLifecycle];\r\n      var lifecycle = shouldBeCaptureLifecycleByCaptured\r\n          && (!shouldBeCaptureLifecycle || shouldBeCaptureLifecycle < shouldBeCaptureLifecycleByCaptured)\r\n          && captureLifecycle\r\n          || rawLifecycle;\r\n      if (REMOVE == lifecycle) {\r\n          var node = glueNode[ELEMENT];\r\n          return (removedNodes.get(node) ||\r\n              (REMOVE == rawLifecycle && !deepGet(glueNode, PROPS + \".on\" + REMOVE)))\r\n              ? DESTROY\r\n              : REMOVE;\r\n      }\r\n      return lifecycle;\r\n  }\n\n  function glueNodeMerger(removedNodes, next, recursion, captureLifecycle, vNode, glueNode) {\r\n      if (!glueNode) {\r\n          return createGlueNode(vNode, next, recursion);\r\n      }\r\n      if (!vNode) {\r\n          deepSet(glueNode, PREV_PROPS, glueNode[PROPS]);\r\n          var lifecycle_1 = resolveLifecycle(REMOVE != captureLifecycle && DESTROY != captureLifecycle ? REMOVE : UPDATE, captureLifecycle, glueNode, removedNodes);\r\n          glueNode[LIFECYCLE] = lifecycle_1;\r\n          glueNode[CHILDREN] = glueNode[CHILDREN].map(function (child) { return recursion(lifecycle_1, null, child); });\r\n          return glueNode;\r\n      }\r\n      deepSet(glueNode, PREV_PROPS, glueNode[PROPS]);\r\n      glueNode[PROPS] = vNode[PROPS];\r\n      glueNode[KEY] = vNode[KEY];\r\n      glueNode[NAME] = vNode[NAME];\r\n      glueNode[LIFECYCLE] = UPDATE;\r\n      var indexedPrevChildren = glueNode[CHILDREN].map(function (child, i) { return (child.i = i, child); });\r\n      var children = vNode[CHILDREN].map(function (child) {\r\n          var prevChild, _prevChild, i;\r\n          for (i = 0; i < indexedPrevChildren.length; i++) {\r\n              _prevChild = indexedPrevChildren[i];\r\n              if (child[NAME] == _prevChild[NAME]\r\n                  && child[KEY] == _prevChild[KEY]\r\n                  && (UPDATE === _prevChild[LIFECYCLE] || CREATE === _prevChild[LIFECYCLE])) {\r\n                  prevChild = _prevChild;\r\n                  break;\r\n              }\r\n          }\r\n          if (prevChild) {\r\n              indexedPrevChildren.splice(i, 1);\r\n              return recursion(UPDATE, child, prevChild);\r\n          }\r\n          else {\r\n              return recursion(UPDATE, child);\r\n          }\r\n      });\r\n      indexedPrevChildren.map(function (child) {\r\n          child = recursion(UPDATE, null, child);\r\n          if (0 === child.i) {\r\n              children.unshift(child);\r\n          }\r\n          else {\r\n              var index = child.i - 1;\r\n              var i = void 0;\r\n              for (i = 0; i < children.length; i++) {\r\n                  if (index === children[i].i) {\r\n                      children.splice(i + 1, 0, child);\r\n                      return;\r\n                  }\r\n              }\r\n              children.push(child);\r\n          }\r\n      });\r\n      glueNode[CHILDREN] = children;\r\n      return glueNode;\r\n  }\n\n  function glueNodeMergerProvider(removedNodes) {\r\n      return function (next, recursion) { return function (captureLifecycle, vNode, glueNode) { return glueNodeMerger(removedNodes, next, recursion, captureLifecycle, vNode, glueNode); }; };\r\n  }\n\n  var XLINK_NS = \"http://www.w3.org/1999/xlink\";\n\n  function updateAttribute(element, name, value, oldValue, isSVG, eventProxy) {\r\n      if (name[0] === \"o\" && name[1] === \"n\") {\r\n          var eventName = name.slice(2);\r\n          if (!(value instanceof Function)) {\r\n              element.removeEventListener(eventName, eventProxy);\r\n          }\r\n          else if (!(oldValue instanceof Function)) {\r\n              element.addEventListener(eventName, eventProxy);\r\n          }\r\n      }\r\n      else {\r\n          var nullOrFalse = value == null || value === false;\r\n          if (name in element &&\r\n              name !== \"list\" &&\r\n              name !== \"draggable\" &&\r\n              name !== \"spellcheck\" &&\r\n              name !== \"translate\" &&\r\n              !isSVG) {\r\n              if (nullOrFalse) {\r\n                  element.removeAttribute(name);\r\n              }\r\n              else {\r\n                  element[name] = value == null ? \"\" : value;\r\n              }\r\n          }\r\n          else {\r\n              var ns = false;\r\n              if (isSVG) {\r\n                  var originName = name;\r\n                  name = name.replace(/^xlink:?/, \"\");\r\n                  ns = name !== originName;\r\n              }\r\n              switch ((nullOrFalse ? 1 : 0) + ((ns ? 1 : 0) << 1)) {\r\n                  case 0:\r\n                      element.setAttribute(name, value);\r\n                      break;\r\n                  case 1:\r\n                      element.removeAttribute(name);\r\n                      break;\r\n                  case 2:\r\n                      element.setAttributeNS(XLINK_NS, name, value);\r\n                      break;\r\n                  case 3:\r\n                      element.removeAttributeNS(XLINK_NS, name);\r\n              }\r\n          }\r\n      }\r\n  }\n\n  function createNode(glueNode, isSVG, eventProxy, eventTargetProps) {\r\n      var props = glueNode[PROPS] || {};\r\n      if (glueNode[NAME] === TEXT_NODE) {\r\n          return document.createTextNode(deepGet(props, TEXT));\r\n      }\r\n      var node = (isSVG = isSVG || glueNode[NAME] === \"svg\")\r\n          ? document.createElementNS(\"http://www.w3.org/2000/svg\", glueNode[NAME])\r\n          : document.createElement(glueNode[NAME]);\r\n      for (var name_1 in props) {\r\n          if ('object' != typeof props[name_1]) {\r\n              updateAttribute(node, name_1, props[name_1], null, isSVG, eventProxy);\r\n          }\r\n      }\r\n      eventTargetProps.set(node, props);\r\n      return node;\r\n  }\n\n  function fireLifeCycleEventProvider(elm, type, detail) {\r\n      if (detail === void 0) { detail = {}; }\r\n      var events = [\r\n          new CustomEvent('lifecycle', { detail: assign({ type: type }, detail) }),\r\n          new CustomEvent(type, { detail: detail })\r\n      ];\r\n      return function () { return events.map(function (event) { return elm.dispatchEvent(event); }); };\r\n  }\n\n  function updateNode(glueNode, isSVG, eventProxy, eventTargetProps) {\r\n      var node = glueNode[ELEMENT];\r\n      var props = glueNode[PROPS];\r\n      var prevProps = deepGet(glueNode, PREV_PROPS) || {};\r\n      var updated = false;\r\n      if (glueNode[NAME] === TEXT_NODE) {\r\n          var value = deepGet(props, TEXT);\r\n          var oldValue = deepGet(prevProps, TEXT);\r\n          updated = value != oldValue;\r\n          if (updated) {\r\n              node.nodeValue = deepGet(props, TEXT);\r\n          }\r\n          return [node, updated];\r\n      }\r\n      for (var name_1 in props) {\r\n          if (('object' != typeof props[name_1]) && (props[name_1] !==\r\n              (name_1 === \"value\" || name_1 === \"checked\"\r\n                  ? node[name_1]\r\n                  : prevProps[name_1]))) {\r\n              updateAttribute(node, name_1, props[name_1], prevProps[name_1], isSVG, eventProxy);\r\n              updated = true;\r\n          }\r\n      }\r\n      eventTargetProps.set(node, props);\r\n      return [node, updated];\r\n  }\n\n  function patcher(mutate, destroys, lifecycleEvents, eventProxy, eventTargetProps, removedNodes, next, recursion, glueNode, isSVG) {\r\n      var _a;\r\n      var newGlueNode = assign({}, glueNode);\r\n      var node = glueNode[ELEMENT];\r\n      if (!isSVG && glueNode[NAME] === 'svg') {\r\n          isSVG = true;\r\n      }\r\n      var lifecycle = newGlueNode[LIFECYCLE];\r\n      var lifecycleEvent;\r\n      var detail = null;\r\n      switch (lifecycle) {\r\n          case CREATE:\r\n              lifecycleEvent = true;\r\n              node = createNode(glueNode, isSVG, eventProxy, eventTargetProps);\r\n              break;\r\n          case UPDATE:\r\n              _a = updateNode(glueNode, isSVG, eventProxy, eventTargetProps), node = _a[0], lifecycleEvent = _a[1];\r\n              break;\r\n          case DESTROY:\r\n              lifecycleEvent = true;\r\n              destroys.push(function () {\r\n                  var parent = node.parentElement || node.parentNode;\r\n                  parent && parent.removeChild(node);\r\n              });\r\n              break;\r\n          case REMOVE:\r\n              if (!removedNodes.has(node)) {\r\n                  removedNodes.set(node, false);\r\n                  lifecycleEvent = true;\r\n                  detail = {\r\n                      done: function () {\r\n                          removedNodes.set(node, true);\r\n                          Promise.resolve({}).then(mutate);\r\n                      }\r\n                  };\r\n              }\r\n      }\r\n      if (lifecycleEvent) {\r\n          lifecycleEvents.push(fireLifeCycleEventProvider(node, lifecycle, detail));\r\n      }\r\n      var children = glueNode[CHILDREN].reduce(function (acc, childNode) {\r\n          var patchedChild = recursion(childNode, isSVG);\r\n          return patchedChild ? acc.concat(patchedChild) : acc;\r\n      }, []);\r\n      if (lifecycle === DESTROY) {\r\n          return null;\r\n      }\r\n      children.map(function (v) { return v[ELEMENT]; }).reduceRight(function (ref, elm) {\r\n          node.insertBefore(elm, ref);\r\n          return elm;\r\n      }, null);\r\n      newGlueNode[CHILDREN] = children;\r\n      newGlueNode[ELEMENT] = node;\r\n      return newGlueNode;\r\n  }\n\n  function patcherProvider(mutate, destroys, lifecycleEvents, eventProxy, eventTargetProps, removedNodes) {\r\n      return function (next, recursion) { return function (glueNode, isSVG) { return patcher(mutate, destroys, lifecycleEvents, eventProxy, eventTargetProps, removedNodes, next, recursion, glueNode, isSVG); }; };\r\n  }\n\n  function isVNode(value) {\r\n      return null != value\r\n          && 'object' === typeof value\r\n          && PROPS in value\r\n          && CHILDREN in value\r\n          && KEY in value\r\n          && NAME in value;\r\n  }\n\n  /**\r\n   * x\r\n   *\r\n   * @param  name {string | Component}\r\n   * @param  props {object}\r\n   * @param  ... {object}\r\n   * @return {VNode}\r\n   */\r\n  function x(name, props) {\r\n      var rest = [];\r\n      for (var _i = 2; _i < arguments.length; _i++) {\r\n          rest[_i - 2] = arguments[_i];\r\n      }\r\n      var children = [];\r\n      while (rest.length) {\r\n          var node = rest.pop();\r\n          if (node && Array.isArray(node)) {\r\n              rest = rest.concat(node);\r\n          }\r\n          else if (node != null && node !== true && node !== false) {\r\n              children.unshift(isVNode(node) && node || createVNode(true, node));\r\n          }\r\n      }\r\n      return createVNode(false, name, props || {}, children);\r\n  }\n\n  function resolveChildren(next, recursion, children, parentNode) {\r\n      return children.reduce(function (childs, child) {\r\n          childs.push.apply(childs, recursion(child, parentNode));\r\n          return childs;\r\n      }, []);\r\n  }\r\n  function resolver(getContext, setContext, next, recursion, node, parentNode) {\r\n      if (!node) {\r\n          return [];\r\n      }\r\n      if (x === node.name) { // Fragment\r\n          return resolveChildren(next, recursion, node[CHILDREN], parentNode);\r\n      }\r\n      var rawProps = node[PROPS];\r\n      var parentProps = parentNode && parentNode[PROPS] || {};\r\n      var path = deepGet(rawProps, PATH);\r\n      if (!path) {\r\n          var parentPath = deepGet(parentProps, PATH) || '';\r\n          var slice = deepGet(rawProps, SLICE);\r\n          path = (parentPath && slice)\r\n              ? parentPath + \".\" + slice\r\n              : (slice || parentPath);\r\n      }\r\n      var sliced = getContext(path);\r\n      if (!sliced) {\r\n          var fill = deepGet(rawProps, FILL) || {};\r\n          sliced = assign({}, fill);\r\n          setContext(sliced, path);\r\n      }\r\n      var context = sliced;\r\n      var extra = assign(assign({}, deepGet(rawProps, EXTRA) || {}), parentNode && deepGet(parentNode, PROPS + \".\" + EXTRA) || {});\r\n      var props = remodelProps(rawProps, context, extra, path);\r\n      var resolveds = (typeof node.name === \"function\"\r\n          ? recursion(node.name(props, node[CHILDREN]), node)\r\n          : [node]).reduce(function (acc, resolved) {\r\n          if (isVNode(resolved)) {\r\n              resolved[CHILDREN] = resolveChildren(next, recursion, resolved[CHILDREN], resolved);\r\n              acc.push(resolved);\r\n          }\r\n          return acc;\r\n      }, []);\r\n      return resolveds;\r\n  }\n\n  function resolverProvider(getContext, setContext) {\r\n      return function (next, recursion) { return function (node, parentNode) { return resolver(getContext, setContext, next, recursion, node, parentNode); }; };\r\n  }\n\n  function rendererProvider(mutate, getContext, setContext /*, view, glueNode */) {\r\n      var eventTargetProps = new WeakMap();\r\n      var removedNodes = new WeakMap();\r\n      var eventProxy = eventProxyProvider(mutate, getContext, eventTargetProps);\r\n      return function () {\r\n          var destroys = [];\r\n          var lifecycleEvents = [];\r\n          return [\r\n              // resolver\r\n              resolverProvider(getContext, setContext),\r\n              // meger\r\n              glueNodeMergerProvider(removedNodes),\r\n              // pather\r\n              patcherProvider(mutate, destroys, lifecycleEvents, eventProxy, eventTargetProps, removedNodes),\r\n              // finallyer\r\n              function () { return function () {\r\n                  lifecycleEvents.reduceRight(function (_, lifecycleEvent) { return lifecycleEvent(); }, 0);\r\n                  destroys.reduceRight(function (_, destroy) { return destroy(); }, 0);\r\n              }; },\r\n          ];\r\n      };\r\n  }\n\n  function rendering(glueNode, view, renderers) {\r\n      var resolverRecursion = function () {\r\n          var args = [];\r\n          for (var _i = 0; _i < arguments.length; _i++) {\r\n              args[_i] = arguments[_i];\r\n          }\r\n          return resolver.apply(null, args);\r\n      };\r\n      var resolver = renderers.map(function (v) { return v[0]; }).reduce(wrapOnion, [noop, resolverRecursion])[0];\r\n      var glueNodeMergerRecursion = function () {\r\n          var args = [];\r\n          for (var _i = 0; _i < arguments.length; _i++) {\r\n              args[_i] = arguments[_i];\r\n          }\r\n          return glueNodeMerger.apply(null, args);\r\n      };\r\n      var glueNodeMerger = renderers.map(function (v) { return v[1]; }).reduce(wrapOnion, [noop, glueNodeMergerRecursion])[0];\r\n      var patcherRecursion = function () {\r\n          var args = [];\r\n          for (var _i = 0; _i < arguments.length; _i++) {\r\n              args[_i] = arguments[_i];\r\n          }\r\n          return patcher.apply(null, args);\r\n      };\r\n      var patcher = renderers.map(function (v) { return v[2]; }).reduce(wrapOnion, [noop, patcherRecursion])[0];\r\n      var finallyer = renderers.map(function (v) { return v[3]; }).reduce(wrapOnion, [noop, noop])[0];\r\n      var vNodes = resolver(x(view, {}, []));\r\n      var container = assign({}, glueNode);\r\n      container[CHILDREN] = vNodes;\r\n      var node = glueNodeMerger(UPDATE, container, glueNode);\r\n      glueNode = patcher(node, 'svg' === node.name);\r\n      finallyer();\r\n      return glueNode;\r\n  }\r\n  function wrapOnion(_a, stack) {\r\n      var next = _a[0], recursion = _a[1];\r\n      return [stack ? stack(next, recursion) : next, recursion];\r\n  }\n\n  /**\r\n   * atto\r\n   *\r\n   * @param  view {(props: Props, children: VNode[]) => VNode}\r\n   * @param  containerOrGlueNode {Element | GlueNode}\r\n   * @param  options {object} default: `{}`\r\n   * @return {Function}\r\n   */\r\n  function atto(view, containerOrGlueNode, options) {\r\n      if (options === void 0) { options = {}; }\r\n      var scheduled = false;\r\n      var glueNode = containerOrGlueNode instanceof Element\r\n          ? createGlueNodeByElement(containerOrGlueNode)\r\n          : containerOrGlueNode;\r\n      var rootProps = remodelProps(glueNode[PROPS]);\r\n      var rootContext = deepGet(rootProps, CONTEXT);\r\n      var middlewares = MIDDLEWARES in options && options[MIDDLEWARES] || [];\r\n      var mutate = mutateProvider(getContext, setContext, scheduleRender);\r\n      var rendererProviders = [rendererProvider]\r\n          .concat(middlewares)\r\n          .map(function (provider) { return provider(mutate, getContext, setContext, view, glueNode); });\r\n      function getContext(path, def) {\r\n          if (def === void 0) { def = {}; }\r\n          return (path ? deepGet(rootContext, path) : rootContext) || def;\r\n      }\r\n      function setContext(newContext, path) {\r\n          if (path) {\r\n              deepSet(rootContext, path, newContext);\r\n          }\r\n          else {\r\n              rootContext = newContext;\r\n          }\r\n      }\r\n      function render() {\r\n          glueNode = rendering(glueNode, view, rendererProviders.map(function (provider) { return provider(); }));\r\n      }\r\n      function rendered() {\r\n          scheduled = false;\r\n      }\r\n      function renderedError(e) {\r\n          rendered();\r\n          throw e;\r\n      }\r\n      function scheduleRender() {\r\n          if (!scheduled) {\r\n              scheduled = true;\r\n              Promise.resolve().then(render).then(rendered, renderedError);\r\n          }\r\n      }\r\n      return mutate;\r\n  }\n\n  /**\r\n   * @param  eventHandler {Function}\r\n   * @return {Function}\r\n   */\r\n  function currentOnly(eventHandler) {\r\n      return function (context, detail, props, event) {\r\n          if (event.currentTarget === event.target) {\r\n              return eventHandler(context, detail, props, event);\r\n          }\r\n      };\r\n  }\n\n  exports.atto = atto;\n  exports.currentOnly = currentOnly;\n  exports.x = x;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"]}